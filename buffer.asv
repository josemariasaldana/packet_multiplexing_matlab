clear all
close all

%añadir retardo lognormal fijo y variable
%calcular delay y jitter para cada paquete original del juego: pensar cómo

IPv4_UDP_HEADER = 28 ; %cabecera IPv4/UDP
IPv6_UDP_HEADER = 48 ; %cabecera IPv6/UDP

%defino la matriz donde almacenaré los resultados de cada prueba con sus
%parámetros
resultados_buffer = zeros(0,0);

%pongo a 0 estas variables para evitar que dé error luego si alguna no se ha usado
kbps_tamano_fijo = 0;
pps_tamano_fijo = 0;
nativo = 0;
nativo_con_repeticiones = 0;
tiempo_limite_buffer = 0;

%lo utilizaré para crear el nombre de fichero
hora_inicio=now;

%abro un fichero en el que guardaré la matriz de resultados. Su nombre incluye día, hora y minuto
file_resultados_buffer = fopen(strcat('.\_resultados_buffer\resultados_buffer_',datestr(hora_inicio, 'yyyy-mm-dd_HH.MM'),'.txt'),'w');

%%% escribo el título de cada resultado %%%%%%%%%%%%%
fprintf(file_resultados_buffer,strcat('tipo_trafico\t kbps_tamano_fijo\t pps_tamano_fijo\t tamano_fijo\t num_jugadores\t PE (ms)\t TO (ms)\t NºPaq\t TH\t politica_buffer\t tamano_buffer (kbytes)\t tiempo_max_buffer(ms)\t kbits_por_segundo_buffer\t paq_por_segundo_buffer\t num_maximo_paq_en_buffer\t retardo_procesado (ms)\t IP_version\t duracion_prueba (seg)\t tanto_por_uno_desechar_inicio\t tanto_por_uno_desechar_final\t kbps_background\t distrib_fondo\t alfa_pareto\t ocupacion_media_bytes\t ocupacion_media_paquetes\t prob_loss_deseado\t prob_loss_total\t prob_loss_background_1\t prob_loss_background_2\t prob_loss_background_3\t prob_loss_background\t trafico_ofrecido_IP_deseado (kbps)\t trafico_ofrecido_IP_background(kbps)\t trafico_ofrecido_IP_bg_1(kbps)\t trafico_ofrecido_IP_bg_2(kbps)\t trafico_ofrecido_IP_bg_3(kbps)\t trafico_cursado_IP_deseado(kbps)\t trafico_cursado_IP_background(kbps)\t trafico_cursado_IP_bg_1(kbps)\t trafico_cursado_IP_bg_2(kbps)\t trafico_cursado_IP_bg_3(kbps)\t num_paq_deseado\t num_paq_bg1\t num_paq_bg2\t num_paq_bg3\t pps_deseado\t pps_bg1\t pps_bg2\t pps_bg3\t  delay_router_deseado(ms)\t delay_mux_router_deseado(ms)\t stdev_router_deseado\t stdev_mux+router_deseado\t stdev_bg1\t stdev_bg2\t stdev_bg3\t stdev_bg\t tamano_medio_IP_deseado','\n'));

%%% Cierro el fichero %%%%%%%%%%
fclose(file_resultados_buffer);

%%%%%%%%%%%%%%%% PARAMETROS GENERALES %%%%%%%%%%%%%%%%%%

%Porcentajes del tiempo que no se tendrán en cuenta para las estadísticas
porcentaje_desechar_inicio = 0.075;
porcentaje_desechar_final = 0.025;
%porcentaje_desechar_inicio = 0.001;
%porcentaje_desechar_final = 0.001;

%si se desea calcular el jitter conjunto del multiplexor y el buffer
%la stdev no se puede sumar directamente, porque existe correlación entre
%la stdev al multiplexar y la del buffer
%poniendo esta variable a 1, el programa calcula las diferencias entre el
%momento de llegada de cada paquete nativo al multiplexor y el momento de
%salida del paquete multiplexado del router
calcular_jitter_conjunto = 0;

%distribución estadística del tráfico de fondo
% 0 exponencial
% 1 pareto
distribucion_trafico_fondo = 0;
alfa_pareto = 0;
%alfa_pareto = 1.9;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%% Empiezan los bucles de pruebas anidados %%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%% Parámetros del tráfico deseado %%%%%%%%
%la variable "tipo_trafico" puede tener estos valores:
%los 900 lo reservo para juegos
%901 'hlcs_1_dedust';
%902 'hl2cs_dedust';
%903 'halo2';
%904 'quake2'; genera unos 13kbps por usuario
%905 'quake3';
%906 'quake4'; genera unos 40kbps por usuario
%907 'etpro_1_fueldump';
%908 'unreal1.0';

%101, 102 y 103 es el tráfico de fondo de cada tamaño
%201 tamaño fijo por kbps
%301 tamaño fijo por pps
for tipo_trafico=201:201

%%%%%%%%%%%%%%%%%%%% Parámetros del tráfico de tamaño fijo: elegir uno de los dos: kbps o pps
%si se está enviando tráfico de juegos, da igual lo que se ponga aquí

%kbps del tráfico de paquetes de tamaño fijo, con distribución de Poisson de tiempo entre paquetes
for kbps_tamano_fijo = 500:100:500
%for pps_tamano_fijo = 100:100:400

%tamaño en bytes de los paquetes de tamaño fijo
for tamano_fijo = 1500:100:1500
%tamano_fijo

%%%%%%%%%%% Duración de la prueba %%%%%%%%%%%%%
%si se va a usar una duración fija
duracion_prueba = 1000; %segundos

% Si se quiere usar una duracion para conseguir 12000 paquetes (Montecarlo) de un tamaño deseado y unos kbps deseados
%son los bps que tendrá el tráfico deseado
%duracion_prueba = 12000 * 8 * tamano_fijo / (kbps_tamano_fijo * 1000)


%%%%%%%%%%%%%%%%%%% parámetros del tráfico de juegos %%%%%%%%%%%%%%%
%si se está enviando tamaño fijo, da igual lo que se ponga aquí.
%en caso de no usar los parámetros, hay que hacer que los bucles se ejecuten una sola vez
for num_jugadores=20:5:20 %número de jugadores

%%%%%%%%%%%%%%%%%%%%%%% Parámetros de la multiplexión de juegos %%%%%%%%%%%%%%%%%%%%%
%Si PE o TO o NP o TH valen 0, el tráfico es nativo

%for PE=0:5:50 %PERIOD que se ha usado para multiplexar
%valores_PE = [0 5 25 50];
%valores_PE = [0 5 15 25];
valores_PE = [0];
for w = 1:size(valores_PE,2)
PE = valores_PE(w);
%for TO=5:5:5 %TIMEOUT que se ha usado para multiplexar. 
TO = PE;

for NP=300:1:300 %Numero máximo de paquetes que se ha usado para multiplexar

for TH=1350:1:1350 %tamaño umbral que se ha usado para multiplexar


%%%%%%%%%%%% Parámetros del buffer %%%%%%%%%%%%%%%%

%si se pone a 1, se da prioridad en el buffer a los paquetes de tráfico deseado
for prioridad = 0:0

%política a usar
% 1 "strict": tamaño fijo estricto 
% 2 "one byte": si queda un byte libre en el buffer, el paquete se acepta 
% 3 "time limited": limitado en tiempo
% 4 "fixed number": cabe un número fijo de paquetes. Da igual lo demás 
for politica_buffer = 1:1

%Para poder hacer el tamaño logarítmico, o como me apetezca, pongo un bucle que coge los valores de un vector
%tamanos_buffer = [10000 20000 50000 100000 200000 500000 1000000];%tamaño del buffer en bytes
tamanos_buffer = [20000 50000 100000];%tamaño del buffer en bytes
%tamanos_buffer = [10000 50000 100000];%tamaño del buffer en bytes
%tamanos_buffer = [10000 50000 100000 500000 1000000];%tamaño del buffer en bytes
%tamanos_buffer = [20000];
for u=1:size(tamanos_buffer,2)
tamano_buffer = tamanos_buffer(u);

%for tamano_buffer=1000:1000:100000 
%for tamano_buffer=10000:1000:100000
    
for kbits_por_segundo_buffer = 2000:50:2000; %dividir por 1.000.000 para hallar los bits por microseg
bits_por_segundo_buffer = 1000 * kbits_por_segundo_buffer; 

for paq_por_segundo_buffer = 20000000:1:20000000; %si es muy grande, no limita
%for paq_por_segundo_buffer = 500:1:500; %si es muy grande, no limita

%número máximo de paquetes en el buffer. Sólo afecta a la política 3
%con un tamaño medio de 600bytes, 10kbytes equivalen a 16 paquetes
%para 1Mbps de BG y 20 players de QuakeIV con PE=5ms, se obtiene en media 601 bytes de tamaño de paquete
numeros_maximo_paq_en_buffer = [16];
%numeros_maximo_paq_en_buffer = [16 83 166];
for z=1:size(numeros_maximo_paq_en_buffer,2); 
num_maximo_paq_en_buffer = numeros_maximo_paq_en_buffer(z);

%milisegundos de límite de tiempo en el buffer. Va en ms. Afecta a la política 4
tiempos_limite_buffer = [400];
%tiempos_limite_buffer = [40 200 400];
for w=1:size(tiempos_limite_buffer,2)
%paso a ms el tiempo_limite_buffer
tiempo_limite_buffer = tiempos_limite_buffer(w);

for retardo_procesado = 0:1:0; %en microseg. Tiempo entre paquetes que salen seguidos. El buffer no es capaz de concatenarlos perfectamente

%%%%%%%%%%%% Versión de IP. Puede ser 4 o 6 %%%%%%%%%%%%%
for IP_version = 4:2:4;

%%%%%%% Cantidad de tráfico de fondo en kbps
for kbps_background = 0:50:2000;

%%%%%%%%%% terminan los bucles anidados %%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%% aquí empieza una prueba, que producirá una línea del fichero de resultados %%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

media_mux_router_deseado = 0;
stdev_mux_router_deseado = 0;

%calculo el tiempo entre paquetes mínimo en microseg
tiempo_entre_paquetes = 1000000 / paq_por_segundo_buffer;

%miro la versión de IP usada
if IP_version == 4
   %se usa IPv4
   IP_UDP_HEADER = IPv4_UDP_HEADER;
else
   %se usa IPv6
   IP_UDP_HEADER = IPv6_UDP_HEADER;
end


%%%%%%%%%%%%%%% BACKGROUND TRAFFIC %%%%%%%%%%%%%
%si se ha definido un tráfico de fondo
if kbps_background ~= 0
    %el valor de la tercera columna está entre 101 y 199: uno para cada flujo
    %paquetes de 40, 576 y 1500 bytes
    switch distribucion_trafico_fondo
        case 0 %exponencial
             if IP_version == 4
                %se usa IPv4
                IP_UDP_HEADER = IPv4_UDP_HEADER;
                nombre_archivos_background=strcat('.\_background\background_',num2str(kbps_background),'_kbps_',num2str(duracion_prueba),'_seg.txt');
            else
                %se usa IPv6
                IP_UDP_HEADER = IPv6_UDP_HEADER;
                nombre_archivos_background=strcat('.\_background\background_IPv6_',num2str(kbps_background),'_kbps_',num2str(duracion_prueba),'_seg.txt');
            end           
        case 1 %pareto
            if IP_version == 4
                %se usa IPv4
                IP_UDP_HEADER = IPv4_UDP_HEADER;
                nombre_archivos_background=strcat('.\_background\background_pareto_alfa_',num2str(alfa_pareto),'_',num2str(kbps_background),'_kbps_',num2str(duracion_prueba),'_seg.txt');
            else
                %se usa IPv6
                IP_UDP_HEADER = IPv6_UDP_HEADER;
                nombre_archivos_background=strcat('.\_background\background_IPv6_pareto_alfa_',num2str(alfa_pareto),'_',num2str(kbps_background),'_kbps_',num2str(duracion_prueba),'_seg.txt');
            end
    end
    %abro el fichero con el tráfico de fondo
    background = load(nombre_archivos_background);
    %le añado una columna de ceros, para que tenga las mismas dimensiones que el tráfico deseado. Esa cuarta columna no se utiliza
    background = [background zeros(size(background(:,1),1),1)];
else
    %si no hay tráfico de fondo, pongo sólo tres paquetes en el instante 0, uno de cada tamaño
    %que se descartarán por los márgenes iniciales
    background = [0 50 101 0; 0 572 102 0; 0 1500 103 0];
end

%%%%%%%%%%%%%%% TRAFICO DESEADO %%%%%%%%%%%%%%%

%tráfico de juegos
if tipo_trafico > 900
    switch(tipo_trafico)
    case 901
        nombre_juego = 'hlcs_1_dedust';
    case 902
        nombre_juego = 'hl2cs_dedust';
    case 903
        nombre_juego = 'halo2';
    case 904
        nombre_juego = 'quake2';
    case 905
        nombre_juego = 'quake3';
    case 906
        nombre_juego = 'quake4';
    case 907
        nombre_juego = 'etpro_1_fueldump';
    case 908
        nombre_juego = 'unreal1.0';
    end
    %nombre_archivos_deseado es la parte común del nombre de los ficheros
    nombre_archivos_deseado=strcat('.\',nombre_juego,'_',num2str(num_jugadores),'\',nombre_juego,'_',num2str(num_jugadores));
    
    %%%% cargo el tráfico nativo del juego en la variable "nativo"
    % si el tráfico ya es nativo, no lo calculo
    if (calcular_jitter_conjunto == 1) && (PE~=0) && (TO~=0)
        nativo = load(strcat(nombre_archivos_deseado,'_time_size_flujo_ordenado.txt'));
        %le añado una columna en blanco para guardar el instante en que sale del buffer
        nativo = [nativo zeros(length(nativo),1)];
    end
    
    %añado los demás parámetros para encontrar el nombre del juego
    if (PE==0) || (TO==0) || (NP == 0) || (TH == 0)
        %si no está multiplexado
        nombre_archivos_deseado = strcat(nombre_archivos_deseado,'_time_size_flujo_ordenado');
    else 
        %si está multiplexado
        nombre_archivos_deseado = strcat(nombre_archivos_deseado,'_PE_',num2str(PE),'_TO_',num2str(TO),'_NP_',num2str(NP),'_TH_',num2str(TH),'_FM_256');
    end

else
    %tamaño fijo por kbps
    if tipo_trafico == 201
        nombre_archivos_deseado=strcat('.\_fixed_size\fixed_size_',num2str(tamano_fijo),'_bytes_',num2str(kbps_tamano_fijo),'_kbps_',num2str(duracion_prueba),'_seg');
    else
        %tamaño fijo por pps
        if tipo_trafico == 301
            nombre_archivos_deseado=strcat('.\_fixed_size\fixed_size_',num2str(tamano_fijo),'_bytes_',num2str(pps_tamano_fijo),'_pps_',num2str(duracion_prueba),'_seg');
        end
    end
end

paquetes_deseado = load(strcat(nombre_archivos_deseado,'.txt'));

%quito los nativos que no están en paquetes_deseado
if (calcular_jitter_conjunto == 1) && (PE~=0) && (TO~=0)
    %calculo la suma de la cuarta columna de los paquetes deseados, que es el número de paquetes multiplexados
    nativo = nativo(1:sum(paquetes_deseado(:,4)),:);
end

%si el tráfico es de juegos, sumo la cabecera IP/UDP a la segunda columna
if floor (tipo_trafico/100) == 9
    paquetes_deseado(:,2) = paquetes_deseado(:,2) + IP_UDP_HEADER;
end

num_paquetes_deseado = length(paquetes_deseado);

%descripción de la matriz "paquetes_deseado":
%columna 1: instante de llegada en microseg
%columna 2: tamaño en bytes a nivel IP
%columna 3: identificador del flujo
%columna 4: número de paquetes multiplexados que lleva. Será 0 si no tiene paquetes multiplexados
%si el tráfico original no lleva la cuarta columna, la añado
if size(paquetes_deseado,2)==3
    paquetes_deseado = [paquetes_deseado zeros(length(paquetes_deseado(:,1)),1)];
end


%%%%%%%%%%%%%% Repito el tráfico deseado tantas veces como haga falta para completar la duración de la prueba %%%%%%%%%%%%%%%%%%%%%%%%
duracion_deseado = paquetes_deseado (size(paquetes_deseado,1),1);
veces_repetir = ceil(1000000 * duracion_prueba / duracion_deseado);

%paquetes_con_repeticiones es la concatenacion de 'paquetes_deseado' varias veces, hasta pasarse de la duracion
paquetes_con_repeticiones = paquetes_deseado;

%hago lo mismo con el tráfico nativo
if (calcular_jitter_conjunto == 1) && (PE~=0) && (TO~=0)
    nativo_con_repeticiones = nativo;
end


for i=2:veces_repetir - 1
    %sumo la duración para que el tiempo absoluto sea correcto
    paquetes_deseado(:,1) = paquetes_deseado(:,1) + duracion_deseado;
    %lo concateno
    paquetes_con_repeticiones = [paquetes_con_repeticiones; paquetes_deseado];
    
    %hago la misma concatenación con el tráfico nativo
    if (calcular_jitter_conjunto == 1) && (PE~=0) && (TO~=0)
        %sumo la duración para que el tiempo absoluto sea correcto
        nativo(:,1) = nativo(:,1) + duracion_deseado;
        %lo concateno
        nativo_con_repeticiones = [nativo_con_repeticiones; nativo];
    end
end

%concateno por última vez sin pasarme de la duración total
%sumo la duración para que el tiempo absoluto sea correcto
paquetes_deseado(:,1) = paquetes_deseado(:,1) + duracion_deseado;
if (calcular_jitter_conjunto == 1) && (PE~=0) && (TO~=0)
    nativo(:,1) = nativo(:,1) + duracion_deseado;
end

%busco la posición en que se pasa de la duracion_prueba
i=1;%variable para contar paquetes multiplexados
j=1;%variable para contar paquetes nativos
while (paquetes_deseado(i,1) < duracion_prueba * 1000000)
    i=i+1;
    if (calcular_jitter_conjunto == 1) && (PE~=0) && (TO~=0)
       j=j+paquetes_deseado(i,4); 
    end
end

%recorto paquetes_deseado hasta que se pasa de duracion_prueba
paquetes_deseado = paquetes_deseado (1:i,:);
if (calcular_jitter_conjunto == 1) && (PE~=0) && (TO~=0)
    nativo = nativo (1:j,:);
end

%lo concateno
paquetes_con_repeticiones = [paquetes_con_repeticiones; paquetes_deseado];
if (calcular_jitter_conjunto == 1) && (PE~=0) && (TO~=0)
    nativo_con_repeticiones = [nativo_con_repeticiones; nativo];
end

%%%%%%%%%%%%%%%%% Junto el tráfico background y el deseado %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%construyo "paquetes" como "paquetes_con_repeticiones" y "background"
paquetes = [paquetes_con_repeticiones ; background];

%elimino estas variables, que ya no hacen falta
clear paquetes_deseado;
clear nativo;
clear paquetes_con_repeticiones;
clear background;

%ordeno el fichero de paquetes según la primera columna (tiempo)
paquetes = sortrows (paquetes,1);

%para pruebas sencillas, descomentar esto
%paquetes=[1 45 101 20;10 50 102 19;12 47 906 18;45 50 906 20;130 41 103 20;150 42 906 19;350 43 102 18;450 44 906 20;460 46 103 20;510 48 906 19;602 47 906 18;705 50 101 20;803 45 906 20;1150 50 102 19;1350 47 103 18;14500 50 102 20];


%añado una columna de ceros (columna 5)para poner el instante en que se empieza a enviar en microseg
paquetes=[paquetes zeros(length(paquetes(:,1)),1)]; 
%añado una columna de ceros (columna 6) para poner el instante en que se termina de enviar
paquetes=[paquetes zeros(length(paquetes(:,1)),1)];
%añado una columna de ceros (columna 7) para poner: 1: aceptado; 0: rechazado por no caber
paquetes=[paquetes zeros(length(paquetes(:,1)),1)];
%añado una columna de ceros (columna 8) para poner la ocupación del buffer justo después de llegar el paquete
paquetes=[paquetes zeros(length(paquetes(:,1)),1)];
%añado una columna de ceros (columna 9) para poner la ocupación del buffer justo después de llegar el paquete
paquetes=[paquetes zeros(length(paquetes(:,1)),1)];

%meto el primer paquete al buffer
%instante en que empieza a enviarse
paquetes(1,5) = retardo_procesado + paquetes(1,1);
%instante en que termina de enviarse
paquetes(1,6) = paquetes(1,5) + (paquetes(1,2)* 8 * 1000000 / bits_por_segundo_buffer); 
%aceptado o no
paquetes(1,7) = 1;
%ocupación del buffer en bytes después de llegar el paquete
paquetes(1,8) = paquetes(1,2);
%ocupación del buffer en paquetes después de llegar el paquete
paquetes(1,9) = 1;

%ocupación del buffer en bytes
ocupacion = paquetes(1,2);
%número de paquetes que hay en el buffer
numero_en_buffer = 1;
%posición del último paquete que se ha empezado a enviar
ultimo_enviado = 1;

primer_bg_sin_enviar = 0;
numero_bg_por_enviar = 0;

%j es el índice que se usa para ver el tiempo en que terminan de enviarse los paquetes
j=1;


%saco por pantalla los datos de la simulación actual
nombre_archivos_deseado
prioridad
politica_buffer
kbits_por_segundo_buffer
kbps_background
switch politica_buffer
    case 1
        tamano_buffer
    case 2
        tamano_buffer
    case 3
        num_maximo_paq_en_buffer
    case 4
        tiempo_limite_buffer
end


%%%%%%%%%%%%%%%% Bucle principal %%%%%%%%%%%%%%%%
for i=2:length(paquetes(:,1))
    
    %j va por detrás de i. Se refiere a los paquetes en cola
    
    %quito del buffer todos los paquetes que están en el buffer y terminan de enviarse antes del instante de la llegada del nuevo paquete
    %el tiempo de final del paquete j debe ser anterior a la llegada del paquete i
    while (paquetes(j,6) <= paquetes(i,1)) && (j < i)
        if politica_buffer ~= 3
            %miro si ha sido aceptado y lo envío
            if paquetes(j,7) == 1
                %lo quito del buffer
                ocupacion = ocupacion - paquetes (j,2);
                numero_en_buffer = numero_en_buffer - 1;
            end

            
        %la política es 3 time-limited. Todos los paquetes se aceptan en principio
        else 
            %si el tiempo que ha pasado desde que llegó hasta que le toca
            %empezar a enviarse es mayor que el tiempo máximo
            if max(paquetes(ultimo_enviado,6), paquetes(ultimo_enviado,5)+tiempo_entre_paquetes) - paquetes(j,1) > 1000 * tiempo_limite_buffer
                %lo descarto
            else
                %se envía
                paquetes(j,7) = 1;
                
                %relleno el momento en que empieza a enviarse
                paquetes(j,5) = retardo_procesado + max(max(paquetes(j,1),paquetes(ultimo_enviado,6)),paquetes(ultimo_enviado,5)+tiempo_entre_paquetes);
            
                %calculo el instante en que termina de enviarse
                paquetes(j,6) = paquetes(j,5) + (paquetes(j,2)* 8 * 1000000 / bits_por_segundo_buffer);

                %actualizo este paquete como el último enviado
                ultimo_enviado = j;
                
                %lo quito del buffer
                ocupacion = ocupacion - paquetes (j,2);
                numero_en_buffer = numero_en_buffer - 1;

            end
        end
        
        %paso al siguiente paquete
        j = j + 1;
    end


    %añado el nuevo paquete que llega, sólo si cabe según:
    %   politica 1: el paquete sólo entra al buffer si cabe entero
    %   política 2: el paquete entra al buffer si hay un byte libre en el buffer
    %   política 3: según el número paquetes
    %   política 4: según el tiempo que lleva en la cola
    switch( politica_buffer )
        case 1 %el paquete sólo entra al buffer si cabe entero

        if (ocupacion + paquetes(i,2) <= tamano_buffer)
            %si no hay prioridades
            if prioridad == 0
            %calculo el instante en que empieza a enviarse
            %es el máximo entre - momento en que llega
            %                   - Final del último enviado
            %                   - Principio del último enviado + tiempo entre paquetes
            %
            %añado un retardo de procesado
            paquetes(i,5) = retardo_procesado + max(max(paquetes(i,1),paquetes(ultimo_enviado,6)),paquetes(ultimo_enviado,5)+tiempo_entre_paquetes);
            
            %calculo el instante en que termina de enviarse
            paquetes(i,6) = paquetes(i,5) + (paquetes(i,2)* 8 * 1000000 / bits_por_segundo_buffer);

            %actualizo este paquete como el último enviado
            ultimo_enviado = i;
        
            paquetes(i,8) = ocupacion + paquetes(i,2);
            paquetes(i,9) = numero_en_buffer + 1;
            ocupacion = ocupacion + paquetes(i,2);
            numero_en_buffer = numero_en_buffer + 1;
            paquetes(i,7)=1;
            
            %si hay prioridades
            else
                if floor(paquetes(i,3)/100) == 1 %es un paquete de tráfico de fondo (sin prioridad)
                    %me lo salto y apunto que está pendiente
                    numero_bg_por_enviar = numero_bg_por_enviar + 1;
                    
                    %si es el primero de bg, lo apunto en la variable
                    if primer_bg_sin_enviar == 0
                        primer_bg_sin_enviar = i;
                    end
                    
                else %es un paquete de tráfico deseado (con prioridad)
   
                    %calculo cuándo empezaría a enviarse el primer_bg_sin
                    %enviar
                    momento_empezaria = retardo_procesado + max(max(paquetes(primer_bg_sin_enviar,1),paquetes(ultimo_enviado,6)),paquetes(ultimo_enviado,5)+tiempo_entre_paquetes);
                    %envío todos los paquetes de bg sin enviar que haya delante del último paquete deseado enviado
                    
                    while (primer_bg_sin_enviar < i) && (primer_bg_sin_enviar ~= 0) && (momento_empezaria < paquetes(i,1))
                        k = primer_bg_sin_enviar;
                        %lo envío
                        paquetes(k,5) = retardo_procesado + max(max(paquetes(k,1),paquetes(ultimo_enviado,6)),paquetes(ultimo_enviado,5)+tiempo_entre_paquetes);
                        %calculo el instante en que termina de enviarse
                        paquetes(k,6) = paquetes(k,5) + (paquetes(k,2)* 8 * 1000000 / bits_por_segundo_buffer);
                                          
                        %actualizo este paquete como el último enviado
                        ultimo_enviado = k;
        
                        paquetes(k,8) = ocupacion + paquetes(k,2);
                        paquetes(k,9) = numero_en_buffer + 1;
                        ocupacion = ocupacion + paquetes(k,2);
                        numero_en_buffer = numero_en_buffer + 1;
                        paquetes(k,7)=1;
                        while (floor(paquetes(primer_bg_sin_enviar,3)/100)~=1) && (primer_bg_sin_enviar < i)
                            primer_bg_sin_enviar = primer_bg_sin_enviar + 1;
                        end
                    end
                    
                    %envío el paquete con prioridad
                    paquetes(i,5) = retardo_procesado + max(max(paquetes(i,1),paquetes(ultimo_enviado,6)),paquetes(ultimo_enviado,5)+tiempo_entre_paquetes);
                    %calculo el instante en que termina de enviarse
                    paquetes(i,6) = paquetes(i,5) + (paquetes(i,2)* 8 * 1000000 / bits_por_segundo_buffer);

                    %actualizo este paquete como el último enviado
                    ultimo_enviado = i;
        
                    paquetes(i,8) = ocupacion + paquetes(i,2);
                    paquetes(i,9) = numero_en_buffer + 1;
                    ocupacion = ocupacion + paquetes(i,2);
                    numero_en_buffer = numero_en_buffer + 1;
                    paquetes(i,7)=1;
                 
                    
                end
            end 
        end
        
        case 2 %politica_buffer ==2. el paquete entra al buffer si hay un byte libre en el buffer
        if (ocupacion < tamano_buffer)
   
            %calculo el instante en que empieza a enviarse
            %añado un retardo de procesado
            paquetes(i,5) = retardo_procesado + max(max(paquetes(i,1),paquetes(ultimo_enviado,6)),paquetes(ultimo_enviado,5)+tiempo_entre_paquetes);
            
            %calculo el instante en que termina de enviarse
            paquetes(i,6) = paquetes(i,5) + (paquetes(i,2)* 8 * 1000000 / bits_por_segundo_buffer);

            %actualizo este paquete como el último enviado
            ultimo_enviado = i;
        
            paquetes(i,8) = ocupacion + paquetes(i,2);
            paquetes(i,9) = numero_en_buffer + 1;
            ocupacion = ocupacion + paquetes(i,2);
            numero_en_buffer = numero_en_buffer + 1;
            paquetes(i,7)=1;
        end
        
        case 3 %politica_buffer==3 política "time-limited". El paquete se acepta siempre
        
            paquetes(i,8) = ocupacion + paquetes(i,2);
            paquetes(i,9) = numero_en_buffer + 1;
            ocupacion = ocupacion + paquetes(i,2);
            numero_en_buffer = numero_en_buffer + 1;
        
        case 4 %politica_buffer ==4. El paquete entra según un límite en número de paquetes, y no por tamaño
        if (numero_en_buffer < num_maximo_paq_en_buffer)
   
            %calculo el instante en que empieza a enviarse
            %añado un retardo de procesado
            paquetes(i,5) = retardo_procesado + max(max(paquetes(i,1),paquetes(ultimo_enviado,6)),paquetes(ultimo_enviado,5)+tiempo_entre_paquetes);
            
            %calculo el instante en que termina de enviarse
            paquetes(i,6) = paquetes(i,5) + (paquetes(i,2)* 8 * 1000000 / bits_por_segundo_buffer);

            %actualizo este paquete como el último enviado
            ultimo_enviado = i;
        
            paquetes(i,8) = ocupacion + paquetes(i,2);
            paquetes(i,9) = numero_en_buffer + 1;
            ocupacion = ocupacion + paquetes(i,2);
            numero_en_buffer = numero_en_buffer + 1;
            paquetes(i,7)=1;
        end

    end    
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% descomentar esto para pruebas
%paquetes

end


%%%%%%%%%%%%%%% Cálculo de estadísticas %%%%%%%%%%%%%%%%%%

% Si tengo que calcular el jitter conjunto, relleno la 4ª columna de nativo_con_repeticiones
%si el tráfico es nativo (PE==0), no calculo esto, porque no hay jitter conjunto, sino sólo el del router
if (calcular_jitter_conjunto == 1) && (PE~=0) && (TO~=0)
    %ordeno por tipo de tráfico y por tiempo
    paquetes = sortrows(paquetes, [3 1]);
    
    posicion_paquetes = 1;
    %busco el primer paquete que no sea de background
    while floor(paquetes(posicion_paquetes,3)/100) == 1
        posicion_paquetes = posicion_paquetes + 1;
    end
    
    %variable para indexar la posicion en la matriz "nativo_con_repeticiones"
    posicion_nativo = 1;
    for i=posicion_paquetes:length(paquetes)
        %si tiene paquetes multiplexados
        if (paquetes(i,4)~=0)
            for j=1:paquetes(i,4)
                %pongo en la cuarta columna de "nativo_con_repeticiones" el momento en que sale del buffer
                nativo_con_repeticiones(posicion_nativo,4)=paquetes(i,6);
                posicion_nativo = posicion_nativo +1;
            end
        else %no tiene paquetes multiplexados
            posicion_nativo = posicion_nativo +1;
        end
    end
    %calculo las posiciones inicial y final para sacar las estadísticas
    comienzo_estadisticas = floor(porcentaje_desechar_inicio*length(nativo_con_repeticiones(:,1)));
    final_estadisticas = floor((1-porcentaje_desechar_final)*length(nativo_con_repeticiones(:,1)));
    
    %recorto la matriz "nativo_con_repeticiones"
    nativo_con_repeticiones = nativo_con_repeticiones (comienzo_estadisticas:final_estadisticas,:);
    
    %quito de "nativo_con_repeticiones" los paquetes que no han entrado al buffer, o sea, los que tengan un valor 0 en la cuarta columna, porque
    %no tienen tiempo de envío
    nativo_con_repeticiones = sortrows(nativo_con_repeticiones,4);
    %busco la posición en que no hay un cero en la cuarta columna
    i=1;
    while (i<length(nativo_con_repeticiones)) && (nativo_con_repeticiones(i,4)==0)
        i = i + 1;
    end
    %si ha acabado el while y ha habido algún aceptado, me quedo con el trozo correspondiente
    if i ~= size (nativo_con_repeticiones,1)
        nativo_con_repeticiones = nativo_con_repeticiones(i:size(nativo_con_repeticiones,1),:);
    end
    
    %calculo la stdev
    stdev_mux_router_deseado = (1/1000) * std(nativo_con_repeticiones(:,4) - nativo_con_repeticiones(:,1));
   
    media_mux_router_deseado = (1/1000) * mean(nativo_con_repeticiones(:,4) - nativo_con_repeticiones(:,1));
    %vuelvo a ordenar por tiempo
    paquetes = sortrows (paquetes, 1);
end

%calculo las posiciones inicial y final para sacar las estadísticas
comienzo_estadisticas = floor(porcentaje_desechar_inicio*length(paquetes(:,1)));
final_estadisticas = floor((1-porcentaje_desechar_final)*length(paquetes(:,1)));

%cojo sólo la parte interesante del resultado para las estadísticas,
%quitando el principio y el final
paquetes_recortado = paquetes (comienzo_estadisticas:final_estadisticas,:);

clear paquetes;

tamano_paquetes_recortado = size(paquetes_recortado,1);

%calculo la media de ocupación del buffer
%aproximo por la media de lo que encuentran los paquetes aceptados al llegar
prob_aceptado = mean(paquetes_recortado(:,7));
ocupacion_media_bytes = sum(paquetes_recortado(:,8) .* paquetes_recortado(:,7)) / sum(paquetes_recortado(:,7));
ocupacion_media_paquetes = sum(paquetes_recortado(:,9) .* paquetes_recortado(:,7)) / sum(paquetes_recortado(:,7));

%antiguo cálculo de la ocupación media. Estaba mal
%bytes_acumulado = 0;
%paquetes_acumulado = 0;
%for i=1:tamano_paquetes_recortado - 1
%    bytes_acumulado = bytes_acumulado + (paquetes_recortado(i,8) * (paquetes_recortado(i+1,5) - paquetes_recortado(i,5)));
%    paquetes_acumulado = paquetes_acumulado + (paquetes_recortado(i,9) * (paquetes_recortado(i+1,5) - paquetes_recortado(i,5)));
%end
%calculo la ocupación media del buffer en bytes
%ocupacion_media_bytes = bytes_acumulado / (paquetes_recortado(tamano_paquetes_recortado,6) - paquetes_recortado(1,6))
%calculo la ocupación media del buffer en número de paquetes
%ocupacion_media_paquetes = paquetes_acumulado / (paquetes_recortado(tamano_paquetes_recortado,6) - paquetes_recortado(1,6))


%%%%%%%%%% calculo de los resultados para cada flujo %%%%%%%%%%%%%%5
%divido la matriz según los flujos
%la ordeno por flujos
paquetes_recortado = sortrows (paquetes_recortado, 3);

if kbps_background ~= 0
    %el primer flujo será el 101: Background pequeño
    comienzo = 1;
    i=1;
    while paquetes_recortado (i+1,3) == paquetes_recortado(i,3)
        i=i+1;
    end
    %ha acabado un flujo
    paquetes_background_1 = paquetes_recortado(comienzo:i,:);

    %el segundo flujo será el 102: Background medio
    comienzo = i+1;
    i=i+1;
    while paquetes_recortado (i+1,3) == paquetes_recortado(i,3)
        i=i+1;
    end
    %ha acabado un flujo
    paquetes_background_2 = paquetes_recortado(comienzo:i,:);

    %el tercer flujo será el 103: Background grande
    comienzo = i+1;
    i=i+1;
    while paquetes_recortado (i+1,3) == paquetes_recortado(i,3)
        i=i+1;
    end
    %ha acabado un flujo
    paquetes_background_3 = paquetes_recortado(comienzo:i,:);

else
    %no hay tráfico background
    paquetes_background_1 = [0 0 101 0 0 0 0 0 0];
    paquetes_background_2 = [0 0 102 0 0 0 0 0 0];
    paquetes_background_3 = [0 0 103 0 0 0 0 0 0];
    i = 0;
end
%hago una variable con todos los paquetes de fondo
paquetes_background = [paquetes_background_1 ; paquetes_background_2 ; paquetes_background_3];

%el cuarto flujo será el 999: tráfico deseado. Será lo que quede
comienzo = i+1;
paquetes_resultado_deseado = paquetes_recortado(comienzo:size(paquetes_recortado,1),:);

%%%%%%%% fin de division de la matriz
%%%%%%%% calculo estadisticas

%prob loss
prob_loss_deseado = 1 - (sum(paquetes_resultado_deseado(:,7))/size(paquetes_resultado_deseado,1));
if kbps_background ~= 0
    prob_loss_background_1 = 1 - (sum(paquetes_background_1(:,7))/size(paquetes_background_1,1));
    prob_loss_background_2 = 1 - (sum(paquetes_background_2(:,7))/size(paquetes_background_2,1));
    prob_loss_background_3 = 1 - (sum(paquetes_background_3(:,7))/size(paquetes_background_3,1));
    prob_loss_background = 1 - (sum(paquetes_background(:,7))/size(paquetes_background,1));
else
    prob_loss_background_1 = 0;
    prob_loss_background_2 = 0;
    prob_loss_background_3 = 0;
    prob_loss_background = 0;
end
prob_loss_total = 1 - mean(paquetes_recortado(:,7));

%trafico a nivel IP kbps
trafico_ofrecido_IP_deseado = 8 * 1000 * sum(paquetes_resultado_deseado(:,2)) / (paquetes_resultado_deseado(size(paquetes_resultado_deseado,1),1) - paquetes_resultado_deseado(1,1));
trafico_cursado_IP_deseado = 8 * 1000 * sum(paquetes_resultado_deseado(:,2) .* paquetes_resultado_deseado(:,7)) / (paquetes_resultado_deseado(size(paquetes_resultado_deseado,1),1) - paquetes_resultado_deseado(1,1));

if kbps_background ~= 0
    trafico_ofrecido_IP_background_1 = 8 * 1000 * sum(paquetes_background_1(:,2)) / (paquetes_background_1(size(paquetes_background_1,1),1) - paquetes_background_1(1,1));
    trafico_cursado_IP_background_1 = 8 * 1000 * sum(paquetes_background_1(:,2) .* paquetes_background_1(:,7)) / (paquetes_background_1(size(paquetes_background_1,1),1) - paquetes_background_1(1,1));
    trafico_ofrecido_IP_background_2 = 8 * 1000 * sum(paquetes_background_2(:,2)) / (paquetes_background_2(size(paquetes_background_2,1),1) - paquetes_background_2(1,1));
    trafico_cursado_IP_background_2 = 8 * 1000 * sum(paquetes_background_2(:,2) .* paquetes_background_2(:,7)) / (paquetes_background_2(size(paquetes_background_2,1),1) - paquetes_background_2(1,1));
    trafico_ofrecido_IP_background_3 = 8 * 1000 * sum(paquetes_background_3(:,2)) / (paquetes_background_3(size(paquetes_background_3,1),1) - paquetes_background_3(1,1));
    trafico_cursado_IP_background_3 = 8 * 1000 * sum(paquetes_background_3(:,2) .* paquetes_background_3(:,7)) / (paquetes_background_3(size(paquetes_background_3,1),1) - paquetes_background_3(1,1));
    trafico_ofrecido_IP_background = 8 * 1000 * sum(paquetes_background(:,2)) / (paquetes_background(size(paquetes_background,1),1) - paquetes_background(1,1));
    trafico_cursado_IP_background = 8 * 1000 * sum(paquetes_background(:,2) .* paquetes_background(:,7)) / (paquetes_background(size(paquetes_background,1),1) - paquetes_background(1,1));
else
    trafico_ofrecido_IP_background_1 = 0;
    trafico_cursado_IP_background_1 = 0;
    trafico_ofrecido_IP_background_2 = 0;
    trafico_cursado_IP_background_2 = 0;
    trafico_ofrecido_IP_background_3 = 0;
    trafico_cursado_IP_background_3 = 0;
    trafico_ofrecido_IP_background = 0;
    trafico_cursado_IP_background = 0;
end

trafico_ofrecido_IP_total = 8 * 1000 * sum(paquetes_recortado(:,2)) / (paquetes_recortado(size(paquetes_recortado,1),1) - paquetes_recortado(1,1));
trafico_cursado_IP_total = 8 * 1000 * sum(paquetes_recortado(:,2) .* paquetes_recortado(:,7)) / (paquetes_recortado(size(paquetes_recortado,1),1) - paquetes_recortado(1,1));

%pps de cada tráfico
pps_deseado = 1000000 * size(paquetes_resultado_deseado,1) / (paquetes_resultado_deseado(size(paquetes_resultado_deseado,1),1) - paquetes_resultado_deseado(1,1));
if kbps_background ~= 0
    pps_background_1 = 1000000 * size(paquetes_background_1,1) / (paquetes_background_1(size(paquetes_background_1,1),1) - paquetes_background_1(1,1));
    pps_background_2 = 1000000 * size(paquetes_background_2,1) / (paquetes_background_2(size(paquetes_background_2,1),1) - paquetes_background_2(1,1));
    pps_background_3 = 1000000 * size(paquetes_background_3,1) / (paquetes_background_3(size(paquetes_background_3,1),1) - paquetes_background_3(1,1));
else
    pps_background_1 = 0;
    pps_background_2 = 0;
    pps_background_3 = 0;
end
%%%% Construyo matrices sólo de paquetes aceptados. Sirven para calcular las estadísticas
%Ordeno paquetes_resultado_deseado por la fila 6(si ha sido aceptado) y luego por la 1(tiempo llegada)
paquetes_resultado_deseado = sortrows(paquetes_resultado_deseado,[7 1]);
%selecciono a partir de las filas que no son cero (utilizo para ello la suma de las que son 1
paquetes_resultado_deseado_aceptados = paquetes_resultado_deseado(1+size(paquetes_resultado_deseado,1)-sum(paquetes_resultado_deseado(:,7)):size(paquetes_resultado_deseado,1),:);
%lo vuelvo a ordenar como estaba
paquetes_resultado_deseado = sortrows(paquetes_resultado_deseado,1);

if kbps_background ~= 0
    paquetes_background_1 = sortrows(paquetes_background_1,[7 1]);
    paquetes_background_1_aceptados = paquetes_background_1(1+size(paquetes_background_1,1)-sum(paquetes_background_1(:,7)):size(paquetes_background_1,1),:);
    paquetes_background_1 = sortrows(paquetes_background_1,1);

    paquetes_background_2 = sortrows(paquetes_background_2,[7 1]);
    paquetes_background_2_aceptados = paquetes_background_2(1+size(paquetes_background_2,1)-sum(paquetes_background_2(:,7)):size(paquetes_background_2,1),:);
    paquetes_background_2 = sortrows(paquetes_background_2,1);

    paquetes_background_3 = sortrows(paquetes_background_3,[7 1]);
    paquetes_background_3_aceptados = paquetes_background_3(1+size(paquetes_background_3,1)-sum(paquetes_background_3(:,7)):size(paquetes_background_3,1),:);
    paquetes_background_3 = sortrows(paquetes_background_3,1);

    paquetes_background = sortrows(paquetes_background,[7 1]);
    paquetes_background_aceptados = paquetes_background(1+size(paquetes_background,1)-sum(paquetes_background(:,7)):size(paquetes_background,1),:);
    paquetes_background = sortrows(paquetes_background,1);
end

% calculo el delay en ms
%delay_router es el retardo total cola + transmision
%delay_transmision es el retardo de transmisión
%delay_buffer es el retardo sólo en la cola
delay_router_deseado = (1/1000) * mean((paquetes_resultado_deseado_aceptados(:,6) - paquetes_resultado_deseado_aceptados(:,1)));
delay_transmision_deseado = (1/1000) * mean((paquetes_resultado_deseado_aceptados(:,6) - paquetes_resultado_deseado_aceptados(:,5)));
delay_buffer_deseado = (1/1000) * mean((paquetes_resultado_deseado_aceptados(:,5) - paquetes_resultado_deseado_aceptados(:,1)));

if kbps_background ~= 0
    delay_router_background_1 = (1/1000) * mean((paquetes_background_1_aceptados(:,6) - paquetes_background_1_aceptados(:,1)));
    delay_transmision_background_1 = (1/1000) * mean((paquetes_background_1_aceptados(:,6) - paquetes_background_1_aceptados(:,5)));
    delay_buffer_background_1 = (1/1000) * mean((paquetes_background_1_aceptados(:,5) - paquetes_background_1_aceptados(:,1)));

    delay_router_background_2 = (1/1000) * mean((paquetes_background_2_aceptados(:,6) - paquetes_background_2_aceptados(:,1)));
    delay_transmision_background_2 = (1/1000) * mean((paquetes_background_2_aceptados(:,6) - paquetes_background_2_aceptados(:,5)));
    delay_buffer_background_2 = (1/1000) * mean((paquetes_background_2_aceptados(:,5) - paquetes_background_2_aceptados(:,1)));

    delay_router_background_3 = (1/1000) * mean((paquetes_background_3_aceptados(:,6) - paquetes_background_3_aceptados(:,1)));
    delay_transmision_background_3 = (1/1000) * mean((paquetes_background_3_aceptados(:,6) - paquetes_background_3_aceptados(:,5)));
    delay_buffer_background_3 = (1/1000) * mean((paquetes_background_3_aceptados(:,5) - paquetes_background_3_aceptados(:,1)));

    delay_router_background = (1/1000) * mean((paquetes_background_aceptados(:,6) - paquetes_background_aceptados(:,1)));
    delay_transmision_background = (1/1000) * mean((paquetes_background_aceptados(:,6) - paquetes_background_aceptados(:,5)));
    delay_buffer_background = (1/1000) * mean((paquetes_background_aceptados(:,5) - paquetes_background_aceptados(:,1)));
else
    delay_router_background_1 = 0;
    delay_transmision_background_1 = 0;
    delay_buffer_background_1 = 0;

    delay_router_background_2 = 0;
    delay_transmision_background_2 = 0;
    delay_buffer_background_2 = 0;

    delay_router_background_3 = 0;
    delay_transmision_background_3 = 0;
    delay_buffer_background_3 = 0;

    delay_router_background = 0;
    delay_transmision_background = 0;
    delay_buffer_background = 0;
end

%calculo la desviación estándar en ms
stdev_router_deseado = (1/1000) * std(paquetes_resultado_deseado_aceptados(:,6) - paquetes_resultado_deseado_aceptados(:,1));
%el tráfico de fondo lo calculo sólo si es diferente de 0
if kbps_background ~= 0
    stdev_router_background_1 = (1/1000) * std(paquetes_background_1_aceptados(:,6) - paquetes_background_1_aceptados(:,1));
    stdev_router_background_2 = (1/1000) * std(paquetes_background_2_aceptados(:,6) - paquetes_background_2_aceptados(:,1));
    stdev_router_background_3 = (1/1000) * std(paquetes_background_3_aceptados(:,6) - paquetes_background_3_aceptados(:,1));
    stdev_router_background = (1/1000) * std(paquetes_background_aceptados(:,6) - paquetes_background_aceptados(:,1));
else
    stdev_router_background_1 = 0;
    stdev_router_background_2 = 0;
    stdev_router_background_3 = 0;
    stdev_router_background = 0;
end

%si el tráfico es nativo, entonces el jitter conjunto es sólo el del router, porque no hay multiplexión
if media_mux_router_deseado == 0
    media_mux_router_deseado = delay_router_deseado;
end   
if stdev_mux_router_deseado == 0
    stdev_mux_router_deseado = stdev_router_deseado;
end


%tamaño medio de paquete del tráfico deseado

tamano_medio_IP_deseado = mean(paquetes_resultado_deseado (:,2));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%% termina una prueba %%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%% pongo el resultado en la matriz de resultados_buffer
resultados_buffer = [tipo_trafico kbps_tamano_fijo pps_tamano_fijo tamano_fijo num_jugadores PE TO NP TH politica_buffer tamano_buffer/1000 tiempo_limite_buffer bits_por_segundo_buffer/1000 paq_por_segundo_buffer num_maximo_paq_en_buffer retardo_procesado*1000 IP_version duracion_prueba porcentaje_desechar_inicio porcentaje_desechar_final kbps_background distribucion_trafico_fondo alfa_pareto ocupacion_media_bytes ocupacion_media_paquetes prob_loss_deseado prob_loss_total prob_loss_background_1 prob_loss_background_2 prob_loss_background_3 prob_loss_background trafico_ofrecido_IP_deseado trafico_ofrecido_IP_background trafico_ofrecido_IP_background_1 trafico_ofrecido_IP_background_2 trafico_ofrecido_IP_background_3  trafico_cursado_IP_deseado trafico_cursado_IP_background trafico_cursado_IP_background_1 trafico_cursado_IP_background_2  trafico_cursado_IP_background_3 size(paquetes_resultado_deseado,1) size(paquetes_background_1,1) size(paquetes_background_2,1) size(paquetes_background_3,1) pps_deseado pps_background_1 pps_background_2 pps_background_3  delay_router_deseado media_mux_router_deseado stdev_router_deseado stdev_mux_router_deseado stdev_router_background_1 stdev_router_background_2 stdev_router_background_3 stdev_router_background tamano_medio_IP_deseado];

%%% Escribo la matriz de resultados en el fichero %%%%%%

%abro el fichero en modo "append" en el que se guardan los resultados
file_resultados_buffer = fopen(strcat('.\_resultados_buffer\resultados_buffer_',datestr(hora_inicio, 'yyyy-mm-dd_HH.MM'),'.txt'),'a');

%escribo el resultado de esta prueba
%for r=1:size(resultados_buffer,1) %para cada línea
    for s=1:size(resultados_buffer,2) %para cada dato
        fprintf(file_resultados_buffer,'%6.4f \t',resultados_buffer(1,s));
    end
    fprintf(file_resultados_buffer,'\n');
%end
%%% Cierro el fichero %%%%%%%%%%
fclose(file_resultados_buffer);

%%%% aqui empiezan los "end" de los bucles anidados %%%%%
end %termina el bucle de kbps_background
end %termina el bucle de IP_version
end %termina el bucle de retardo_procesado
end %termina el bucle de tiempo_limite_buffer
end %termina el bucle de num_maximo_paq_en_buffer
end %termina el bucle de paquetes_por_segundo
end %termina el bucle de bits_por_segundo_buffer
end %termina el bucle de tamano_buffer
end %termina el bucle de políticas de buffer
end %termina el bucle de prioridad
end %termina el bucle de TH
end %termina el bucle de NP
%end %termina el bucle de TO
end %termina el bucle de PE
end %termina el bucle de num_jugadores
end %termina el bucle del tamaño de los paquetes tamano_fijo
end %termina el bucle kbps_tamano_fijo o pps_tamano_fijo
end %termina el bucle de tipo_trafico

%%%% Terminan los bucles de pruebas anidados %%%%%%

